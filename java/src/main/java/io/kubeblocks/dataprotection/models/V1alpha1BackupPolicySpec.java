/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.25.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.kubeblocks.dataprotection.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.kubeblocks.dataprotection.models.V1alpha1BackupPolicySpecBackupMethodsInner;
import io.kubeblocks.dataprotection.models.V1alpha1BackupPolicySpecBackupMethodsInnerTargetsInner;
import io.kubeblocks.dataprotection.models.V1alpha1BackupPolicySpecEncryptionConfig;
import io.kubeblocks.dataprotection.models.V1alpha1BackupPolicySpecTarget;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import io.kubernetes.client.openapi.JSON;

/**
 * BackupPolicySpec defines the desired state of BackupPolicy
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-08-05T14:01:13.011869Z[Etc/UTC]")
public class V1alpha1BackupPolicySpec {
  public static final String SERIALIZED_NAME_BACKOFF_LIMIT = "backoffLimit";
  @SerializedName(SERIALIZED_NAME_BACKOFF_LIMIT)
  private Integer backoffLimit;

  public static final String SERIALIZED_NAME_BACKUP_METHODS = "backupMethods";
  @SerializedName(SERIALIZED_NAME_BACKUP_METHODS)
  private List<V1alpha1BackupPolicySpecBackupMethodsInner> backupMethods = new ArrayList<>();

  public static final String SERIALIZED_NAME_BACKUP_REPO_NAME = "backupRepoName";
  @SerializedName(SERIALIZED_NAME_BACKUP_REPO_NAME)
  private String backupRepoName;

  public static final String SERIALIZED_NAME_ENCRYPTION_CONFIG = "encryptionConfig";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_CONFIG)
  private V1alpha1BackupPolicySpecEncryptionConfig encryptionConfig;

  public static final String SERIALIZED_NAME_PATH_PREFIX = "pathPrefix";
  @SerializedName(SERIALIZED_NAME_PATH_PREFIX)
  private String pathPrefix;

  public static final String SERIALIZED_NAME_TARGET = "target";
  @SerializedName(SERIALIZED_NAME_TARGET)
  private V1alpha1BackupPolicySpecTarget target;

  public static final String SERIALIZED_NAME_TARGETS = "targets";
  @SerializedName(SERIALIZED_NAME_TARGETS)
  private List<V1alpha1BackupPolicySpecBackupMethodsInnerTargetsInner> targets;

  public static final String SERIALIZED_NAME_USE_KOPIA = "useKopia";
  @SerializedName(SERIALIZED_NAME_USE_KOPIA)
  private Boolean useKopia;

  public V1alpha1BackupPolicySpec() {
  }

  public V1alpha1BackupPolicySpec backoffLimit(Integer backoffLimit) {
    
    this.backoffLimit = backoffLimit;
    return this;
  }

   /**
   * Specifies the number of retries before marking the backup as failed.
   * minimum: 0
   * maximum: 10
   * @return backoffLimit
  **/
  @jakarta.annotation.Nullable
  public Integer getBackoffLimit() {
    return backoffLimit;
  }


  public void setBackoffLimit(Integer backoffLimit) {
    this.backoffLimit = backoffLimit;
  }


  public V1alpha1BackupPolicySpec backupMethods(List<V1alpha1BackupPolicySpecBackupMethodsInner> backupMethods) {
    
    this.backupMethods = backupMethods;
    return this;
  }

  public V1alpha1BackupPolicySpec addBackupMethodsItem(V1alpha1BackupPolicySpecBackupMethodsInner backupMethodsItem) {
    if (this.backupMethods == null) {
      this.backupMethods = new ArrayList<>();
    }
    this.backupMethods.add(backupMethodsItem);
    return this;
  }

   /**
   * Defines the backup methods.
   * @return backupMethods
  **/
  @jakarta.annotation.Nonnull
  public List<V1alpha1BackupPolicySpecBackupMethodsInner> getBackupMethods() {
    return backupMethods;
  }


  public void setBackupMethods(List<V1alpha1BackupPolicySpecBackupMethodsInner> backupMethods) {
    this.backupMethods = backupMethods;
  }


  public V1alpha1BackupPolicySpec backupRepoName(String backupRepoName) {
    
    this.backupRepoName = backupRepoName;
    return this;
  }

   /**
   * Specifies the name of BackupRepo where the backup data will be stored. If not set, data will be stored in the default backup repository.
   * @return backupRepoName
  **/
  @jakarta.annotation.Nullable
  public String getBackupRepoName() {
    return backupRepoName;
  }


  public void setBackupRepoName(String backupRepoName) {
    this.backupRepoName = backupRepoName;
  }


  public V1alpha1BackupPolicySpec encryptionConfig(V1alpha1BackupPolicySpecEncryptionConfig encryptionConfig) {
    
    this.encryptionConfig = encryptionConfig;
    return this;
  }

   /**
   * Get encryptionConfig
   * @return encryptionConfig
  **/
  @jakarta.annotation.Nullable
  public V1alpha1BackupPolicySpecEncryptionConfig getEncryptionConfig() {
    return encryptionConfig;
  }


  public void setEncryptionConfig(V1alpha1BackupPolicySpecEncryptionConfig encryptionConfig) {
    this.encryptionConfig = encryptionConfig;
  }


  public V1alpha1BackupPolicySpec pathPrefix(String pathPrefix) {
    
    this.pathPrefix = pathPrefix;
    return this;
  }

   /**
   * Specifies the directory inside the backup repository to store the backup. This path is relative to the path of the backup repository.
   * @return pathPrefix
  **/
  @jakarta.annotation.Nullable
  public String getPathPrefix() {
    return pathPrefix;
  }


  public void setPathPrefix(String pathPrefix) {
    this.pathPrefix = pathPrefix;
  }


  public V1alpha1BackupPolicySpec target(V1alpha1BackupPolicySpecTarget target) {
    
    this.target = target;
    return this;
  }

   /**
   * Get target
   * @return target
  **/
  @jakarta.annotation.Nullable
  public V1alpha1BackupPolicySpecTarget getTarget() {
    return target;
  }


  public void setTarget(V1alpha1BackupPolicySpecTarget target) {
    this.target = target;
  }


  public V1alpha1BackupPolicySpec targets(List<V1alpha1BackupPolicySpecBackupMethodsInnerTargetsInner> targets) {
    
    this.targets = targets;
    return this;
  }

  public V1alpha1BackupPolicySpec addTargetsItem(V1alpha1BackupPolicySpecBackupMethodsInnerTargetsInner targetsItem) {
    if (this.targets == null) {
      this.targets = new ArrayList<>();
    }
    this.targets.add(targetsItem);
    return this;
  }

   /**
   * Specifies multiple target information for backup operations. This includes details such as the target pod and cluster connection credentials. All specified targets will be backed up collectively. optional
   * @return targets
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1BackupPolicySpecBackupMethodsInnerTargetsInner> getTargets() {
    return targets;
  }


  public void setTargets(List<V1alpha1BackupPolicySpecBackupMethodsInnerTargetsInner> targets) {
    this.targets = targets;
  }


  public V1alpha1BackupPolicySpec useKopia(Boolean useKopia) {
    
    this.useKopia = useKopia;
    return this;
  }

   /**
   * Specifies whether backup data should be stored in a Kopia repository.   Data within the Kopia repository is both compressed and encrypted. Furthermore, data deduplication is implemented across various backups of the same cluster. This approach significantly reduces the actual storage usage, particularly for clusters with a low update frequency.   NOTE: This feature should NOT be enabled when using KubeBlocks Community Edition, otherwise the backup will not be processed.
   * @return useKopia
  **/
  @jakarta.annotation.Nullable
  public Boolean getUseKopia() {
    return useKopia;
  }


  public void setUseKopia(Boolean useKopia) {
    this.useKopia = useKopia;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1alpha1BackupPolicySpec v1alpha1BackupPolicySpec = (V1alpha1BackupPolicySpec) o;
    return Objects.equals(this.backoffLimit, v1alpha1BackupPolicySpec.backoffLimit) &&
        Objects.equals(this.backupMethods, v1alpha1BackupPolicySpec.backupMethods) &&
        Objects.equals(this.backupRepoName, v1alpha1BackupPolicySpec.backupRepoName) &&
        Objects.equals(this.encryptionConfig, v1alpha1BackupPolicySpec.encryptionConfig) &&
        Objects.equals(this.pathPrefix, v1alpha1BackupPolicySpec.pathPrefix) &&
        Objects.equals(this.target, v1alpha1BackupPolicySpec.target) &&
        Objects.equals(this.targets, v1alpha1BackupPolicySpec.targets) &&
        Objects.equals(this.useKopia, v1alpha1BackupPolicySpec.useKopia);
  }

  @Override
  public int hashCode() {
    return Objects.hash(backoffLimit, backupMethods, backupRepoName, encryptionConfig, pathPrefix, target, targets, useKopia);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1alpha1BackupPolicySpec {\n");
    sb.append("    backoffLimit: ").append(toIndentedString(backoffLimit)).append("\n");
    sb.append("    backupMethods: ").append(toIndentedString(backupMethods)).append("\n");
    sb.append("    backupRepoName: ").append(toIndentedString(backupRepoName)).append("\n");
    sb.append("    encryptionConfig: ").append(toIndentedString(encryptionConfig)).append("\n");
    sb.append("    pathPrefix: ").append(toIndentedString(pathPrefix)).append("\n");
    sb.append("    target: ").append(toIndentedString(target)).append("\n");
    sb.append("    targets: ").append(toIndentedString(targets)).append("\n");
    sb.append("    useKopia: ").append(toIndentedString(useKopia)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("backoffLimit");
    openapiFields.add("backupMethods");
    openapiFields.add("backupRepoName");
    openapiFields.add("encryptionConfig");
    openapiFields.add("pathPrefix");
    openapiFields.add("target");
    openapiFields.add("targets");
    openapiFields.add("useKopia");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("backupMethods");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to V1alpha1BackupPolicySpec
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!V1alpha1BackupPolicySpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1alpha1BackupPolicySpec is not found in the empty JSON string", V1alpha1BackupPolicySpec.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!V1alpha1BackupPolicySpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1alpha1BackupPolicySpec` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : V1alpha1BackupPolicySpec.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      // ensure the json data is an array
      if (!jsonObj.get("backupMethods").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `backupMethods` to be an array in the JSON string but got `%s`", jsonObj.get("backupMethods").toString()));
      }

      JsonArray jsonArraybackupMethods = jsonObj.getAsJsonArray("backupMethods");
      // validate the required field `backupMethods` (array)
      for (int i = 0; i < jsonArraybackupMethods.size(); i++) {
        V1alpha1BackupPolicySpecBackupMethodsInner.validateJsonObject(jsonArraybackupMethods.get(i).getAsJsonObject());
      };
      if ((jsonObj.get("backupRepoName") != null && !jsonObj.get("backupRepoName").isJsonNull()) && !jsonObj.get("backupRepoName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `backupRepoName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("backupRepoName").toString()));
      }
      // validate the optional field `encryptionConfig`
      if (jsonObj.get("encryptionConfig") != null && !jsonObj.get("encryptionConfig").isJsonNull()) {
        V1alpha1BackupPolicySpecEncryptionConfig.validateJsonObject(jsonObj.getAsJsonObject("encryptionConfig"));
      }
      if ((jsonObj.get("pathPrefix") != null && !jsonObj.get("pathPrefix").isJsonNull()) && !jsonObj.get("pathPrefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pathPrefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pathPrefix").toString()));
      }
      // validate the optional field `target`
      if (jsonObj.get("target") != null && !jsonObj.get("target").isJsonNull()) {
        V1alpha1BackupPolicySpecTarget.validateJsonObject(jsonObj.getAsJsonObject("target"));
      }
      if (jsonObj.get("targets") != null && !jsonObj.get("targets").isJsonNull()) {
        JsonArray jsonArraytargets = jsonObj.getAsJsonArray("targets");
        if (jsonArraytargets != null) {
          // ensure the json data is an array
          if (!jsonObj.get("targets").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `targets` to be an array in the JSON string but got `%s`", jsonObj.get("targets").toString()));
          }

          // validate the optional field `targets` (array)
          for (int i = 0; i < jsonArraytargets.size(); i++) {
            V1alpha1BackupPolicySpecBackupMethodsInnerTargetsInner.validateJsonObject(jsonArraytargets.get(i).getAsJsonObject());
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1alpha1BackupPolicySpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1alpha1BackupPolicySpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1alpha1BackupPolicySpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1alpha1BackupPolicySpec.class));

       return (TypeAdapter<T>) new TypeAdapter<V1alpha1BackupPolicySpec>() {
           @Override
           public void write(JsonWriter out, V1alpha1BackupPolicySpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1alpha1BackupPolicySpec read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of V1alpha1BackupPolicySpec given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of V1alpha1BackupPolicySpec
  * @throws IOException if the JSON string is invalid with respect to V1alpha1BackupPolicySpec
  */
  public static V1alpha1BackupPolicySpec fromJson(String jsonString) throws IOException {
    return new JSON().getGson().fromJson(jsonString, V1alpha1BackupPolicySpec.class);
  }

 /**
  * Convert an instance of V1alpha1BackupPolicySpec to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return new JSON().getGson().toJson(this);
  }
}

