/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.25.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.kubeblocks.workloads.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.kubeblocks.workloads.models.V1alpha1InstanceSetSpecCredential;
import io.kubeblocks.workloads.models.V1alpha1InstanceSetSpecDefaultTemplateOrdinals;
import io.kubeblocks.workloads.models.V1alpha1InstanceSetSpecInstancesInner;
import io.kubeblocks.workloads.models.V1alpha1InstanceSetSpecInstancesInnerVolumeClaimTemplatesInner;
import io.kubeblocks.workloads.models.V1alpha1InstanceSetSpecMembershipReconfiguration;
import io.kubeblocks.workloads.models.V1alpha1InstanceSetSpecRoleProbe;
import io.kubeblocks.workloads.models.V1alpha1InstanceSetSpecRolesInner;
import io.kubeblocks.workloads.models.V1alpha1InstanceSetSpecSelector;
import io.kubeblocks.workloads.models.V1alpha1InstanceSetSpecTemplate;
import io.kubeblocks.workloads.models.V1alpha1InstanceSetSpecUpdateStrategy;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import io.kubernetes.client.openapi.JSON;

/**
 * Defines the desired state of the state machine. It includes the configuration details for the state machine.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-08-05T14:03:17.809844Z[Etc/UTC]")
public class V1alpha1InstanceSetSpec {
  public static final String SERIALIZED_NAME_CREDENTIAL = "credential";
  @SerializedName(SERIALIZED_NAME_CREDENTIAL)
  private V1alpha1InstanceSetSpecCredential credential;

  public static final String SERIALIZED_NAME_DEFAULT_TEMPLATE_ORDINALS = "defaultTemplateOrdinals";
  @SerializedName(SERIALIZED_NAME_DEFAULT_TEMPLATE_ORDINALS)
  private V1alpha1InstanceSetSpecDefaultTemplateOrdinals defaultTemplateOrdinals;

  public static final String SERIALIZED_NAME_INSTANCES = "instances";
  @SerializedName(SERIALIZED_NAME_INSTANCES)
  private List<V1alpha1InstanceSetSpecInstancesInner> instances;

  /**
   * Members(Pods) update strategy.   - serial: update Members one by one that guarantee minimum component unavailable time. - bestEffortParallel: update Members in parallel that guarantee minimum component un-writable time. - parallel: force parallel
   */
  @JsonAdapter(MemberUpdateStrategyEnum.Adapter.class)
  public enum MemberUpdateStrategyEnum {
    SERIAL("Serial"),
    
    BESTEFFORTPARALLEL("BestEffortParallel"),
    
    PARALLEL("Parallel");

    private String value;

    MemberUpdateStrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MemberUpdateStrategyEnum fromValue(String value) {
      for (MemberUpdateStrategyEnum b : MemberUpdateStrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MemberUpdateStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MemberUpdateStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MemberUpdateStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MemberUpdateStrategyEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_MEMBER_UPDATE_STRATEGY = "memberUpdateStrategy";
  @SerializedName(SERIALIZED_NAME_MEMBER_UPDATE_STRATEGY)
  private MemberUpdateStrategyEnum memberUpdateStrategy;

  public static final String SERIALIZED_NAME_MEMBERSHIP_RECONFIGURATION = "membershipReconfiguration";
  @SerializedName(SERIALIZED_NAME_MEMBERSHIP_RECONFIGURATION)
  private V1alpha1InstanceSetSpecMembershipReconfiguration membershipReconfiguration;

  public static final String SERIALIZED_NAME_MIN_READY_SECONDS = "minReadySeconds";
  @SerializedName(SERIALIZED_NAME_MIN_READY_SECONDS)
  private Integer minReadySeconds;

  public static final String SERIALIZED_NAME_OFFLINE_INSTANCES = "offlineInstances";
  @SerializedName(SERIALIZED_NAME_OFFLINE_INSTANCES)
  private List<String> offlineInstances;

  public static final String SERIALIZED_NAME_PARALLEL_POD_MANAGEMENT_CONCURRENCY = "parallelPodManagementConcurrency";
  @SerializedName(SERIALIZED_NAME_PARALLEL_POD_MANAGEMENT_CONCURRENCY)
  private Object parallelPodManagementConcurrency;

  public static final String SERIALIZED_NAME_PAUSED = "paused";
  @SerializedName(SERIALIZED_NAME_PAUSED)
  private Boolean paused;

  public static final String SERIALIZED_NAME_POD_MANAGEMENT_POLICY = "podManagementPolicy";
  @SerializedName(SERIALIZED_NAME_POD_MANAGEMENT_POLICY)
  private String podManagementPolicy;

  public static final String SERIALIZED_NAME_POD_UPDATE_POLICY = "podUpdatePolicy";
  @SerializedName(SERIALIZED_NAME_POD_UPDATE_POLICY)
  private String podUpdatePolicy;

  public static final String SERIALIZED_NAME_REPLICAS = "replicas";
  @SerializedName(SERIALIZED_NAME_REPLICAS)
  private Integer replicas;

  public static final String SERIALIZED_NAME_ROLE_PROBE = "roleProbe";
  @SerializedName(SERIALIZED_NAME_ROLE_PROBE)
  private V1alpha1InstanceSetSpecRoleProbe roleProbe;

  public static final String SERIALIZED_NAME_ROLES = "roles";
  @SerializedName(SERIALIZED_NAME_ROLES)
  private List<V1alpha1InstanceSetSpecRolesInner> roles;

  public static final String SERIALIZED_NAME_SELECTOR = "selector";
  @SerializedName(SERIALIZED_NAME_SELECTOR)
  private V1alpha1InstanceSetSpecSelector selector;

  public static final String SERIALIZED_NAME_SERVICE = "service";
  @SerializedName(SERIALIZED_NAME_SERVICE)
  private Object service;

  public static final String SERIALIZED_NAME_TEMPLATE = "template";
  @SerializedName(SERIALIZED_NAME_TEMPLATE)
  private V1alpha1InstanceSetSpecTemplate template;

  public static final String SERIALIZED_NAME_UPDATE_STRATEGY = "updateStrategy";
  @SerializedName(SERIALIZED_NAME_UPDATE_STRATEGY)
  private V1alpha1InstanceSetSpecUpdateStrategy updateStrategy;

  public static final String SERIALIZED_NAME_VOLUME_CLAIM_TEMPLATES = "volumeClaimTemplates";
  @SerializedName(SERIALIZED_NAME_VOLUME_CLAIM_TEMPLATES)
  private List<V1alpha1InstanceSetSpecInstancesInnerVolumeClaimTemplatesInner> volumeClaimTemplates;

  public V1alpha1InstanceSetSpec() {
  }

  public V1alpha1InstanceSetSpec credential(V1alpha1InstanceSetSpecCredential credential) {
    
    this.credential = credential;
    return this;
  }

   /**
   * Get credential
   * @return credential
  **/
  @jakarta.annotation.Nullable
  public V1alpha1InstanceSetSpecCredential getCredential() {
    return credential;
  }


  public void setCredential(V1alpha1InstanceSetSpecCredential credential) {
    this.credential = credential;
  }


  public V1alpha1InstanceSetSpec defaultTemplateOrdinals(V1alpha1InstanceSetSpecDefaultTemplateOrdinals defaultTemplateOrdinals) {
    
    this.defaultTemplateOrdinals = defaultTemplateOrdinals;
    return this;
  }

   /**
   * Get defaultTemplateOrdinals
   * @return defaultTemplateOrdinals
  **/
  @jakarta.annotation.Nullable
  public V1alpha1InstanceSetSpecDefaultTemplateOrdinals getDefaultTemplateOrdinals() {
    return defaultTemplateOrdinals;
  }


  public void setDefaultTemplateOrdinals(V1alpha1InstanceSetSpecDefaultTemplateOrdinals defaultTemplateOrdinals) {
    this.defaultTemplateOrdinals = defaultTemplateOrdinals;
  }


  public V1alpha1InstanceSetSpec instances(List<V1alpha1InstanceSetSpecInstancesInner> instances) {
    
    this.instances = instances;
    return this;
  }

  public V1alpha1InstanceSetSpec addInstancesItem(V1alpha1InstanceSetSpecInstancesInner instancesItem) {
    if (this.instances == null) {
      this.instances = new ArrayList<>();
    }
    this.instances.add(instancesItem);
    return this;
  }

   /**
   * Overrides values in default Template.   Instance is the fundamental unit managed by KubeBlocks. It represents a Pod with additional objects such as PVCs, Services, ConfigMaps, etc. An InstanceSet manages instances with a total count of Replicas, and by default, all these instances are generated from the same template. The InstanceTemplate provides a way to override values in the default template, allowing the InstanceSet to manage instances from different templates.   The naming convention for instances (pods) based on the InstanceSet Name, InstanceTemplate Name, and ordinal. The constructed instance name follows the pattern: $(instance_set.name)-$(template.name)-$(ordinal). By default, the ordinal starts from 0 for each InstanceTemplate. It is important to ensure that the Name of each InstanceTemplate is unique.   The sum of replicas across all InstanceTemplates should not exceed the total number of Replicas specified for the InstanceSet. Any remaining replicas will be generated using the default template and will follow the default naming rules.
   * @return instances
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1InstanceSetSpecInstancesInner> getInstances() {
    return instances;
  }


  public void setInstances(List<V1alpha1InstanceSetSpecInstancesInner> instances) {
    this.instances = instances;
  }


  public V1alpha1InstanceSetSpec memberUpdateStrategy(MemberUpdateStrategyEnum memberUpdateStrategy) {
    
    this.memberUpdateStrategy = memberUpdateStrategy;
    return this;
  }

   /**
   * Members(Pods) update strategy.   - serial: update Members one by one that guarantee minimum component unavailable time. - bestEffortParallel: update Members in parallel that guarantee minimum component un-writable time. - parallel: force parallel
   * @return memberUpdateStrategy
  **/
  @jakarta.annotation.Nullable
  public MemberUpdateStrategyEnum getMemberUpdateStrategy() {
    return memberUpdateStrategy;
  }


  public void setMemberUpdateStrategy(MemberUpdateStrategyEnum memberUpdateStrategy) {
    this.memberUpdateStrategy = memberUpdateStrategy;
  }


  public V1alpha1InstanceSetSpec membershipReconfiguration(V1alpha1InstanceSetSpecMembershipReconfiguration membershipReconfiguration) {
    
    this.membershipReconfiguration = membershipReconfiguration;
    return this;
  }

   /**
   * Get membershipReconfiguration
   * @return membershipReconfiguration
  **/
  @jakarta.annotation.Nullable
  public V1alpha1InstanceSetSpecMembershipReconfiguration getMembershipReconfiguration() {
    return membershipReconfiguration;
  }


  public void setMembershipReconfiguration(V1alpha1InstanceSetSpecMembershipReconfiguration membershipReconfiguration) {
    this.membershipReconfiguration = membershipReconfiguration;
  }


  public V1alpha1InstanceSetSpec minReadySeconds(Integer minReadySeconds) {
    
    this.minReadySeconds = minReadySeconds;
    return this;
  }

   /**
   * Defines the minimum number of seconds a newly created pod should be ready without any of its container crashing to be considered available. Defaults to 0, meaning the pod will be considered available as soon as it is ready.
   * minimum: 0
   * @return minReadySeconds
  **/
  @jakarta.annotation.Nullable
  public Integer getMinReadySeconds() {
    return minReadySeconds;
  }


  public void setMinReadySeconds(Integer minReadySeconds) {
    this.minReadySeconds = minReadySeconds;
  }


  public V1alpha1InstanceSetSpec offlineInstances(List<String> offlineInstances) {
    
    this.offlineInstances = offlineInstances;
    return this;
  }

  public V1alpha1InstanceSetSpec addOfflineInstancesItem(String offlineInstancesItem) {
    if (this.offlineInstances == null) {
      this.offlineInstances = new ArrayList<>();
    }
    this.offlineInstances.add(offlineInstancesItem);
    return this;
  }

   /**
   * Specifies the names of instances to be transitioned to offline status.   Marking an instance as offline results in the following:   1. The associated pod is stopped, and its PersistentVolumeClaim (PVC) is retained for potential    future reuse or data recovery, but it is no longer actively used. 2. The ordinal number assigned to this instance is preserved, ensuring it remains unique    and avoiding conflicts with new instances.   Setting instances to offline allows for a controlled scale-in process, preserving their data and maintaining ordinal consistency within the cluster. Note that offline instances and their associated resources, such as PVCs, are not automatically deleted. The cluster administrator must manually manage the cleanup and removal of these resources when they are no longer needed.
   * @return offlineInstances
  **/
  @jakarta.annotation.Nullable
  public List<String> getOfflineInstances() {
    return offlineInstances;
  }


  public void setOfflineInstances(List<String> offlineInstances) {
    this.offlineInstances = offlineInstances;
  }


  public V1alpha1InstanceSetSpec parallelPodManagementConcurrency(Object parallelPodManagementConcurrency) {
    
    this.parallelPodManagementConcurrency = parallelPodManagementConcurrency;
    return this;
  }

   /**
   * Controls the concurrency of pods during initial scale up, when replacing pods on nodes, or when scaling down. It only used when &#x60;PodManagementPolicy&#x60; is set to &#x60;Parallel&#x60;. The default Concurrency is 100%.
   * @return parallelPodManagementConcurrency
  **/
  @jakarta.annotation.Nullable
  public Object getParallelPodManagementConcurrency() {
    return parallelPodManagementConcurrency;
  }


  public void setParallelPodManagementConcurrency(Object parallelPodManagementConcurrency) {
    this.parallelPodManagementConcurrency = parallelPodManagementConcurrency;
  }


  public V1alpha1InstanceSetSpec paused(Boolean paused) {
    
    this.paused = paused;
    return this;
  }

   /**
   * Indicates that the InstanceSet is paused, meaning the reconciliation of this InstanceSet object will be paused.
   * @return paused
  **/
  @jakarta.annotation.Nullable
  public Boolean getPaused() {
    return paused;
  }


  public void setPaused(Boolean paused) {
    this.paused = paused;
  }


  public V1alpha1InstanceSetSpec podManagementPolicy(String podManagementPolicy) {
    
    this.podManagementPolicy = podManagementPolicy;
    return this;
  }

   /**
   * Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down.   The default policy is &#x60;OrderedReady&#x60;, where pods are created in increasing order and the controller waits until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is &#x60;Parallel&#x60; which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.   Note: This field will be removed in future version.
   * @return podManagementPolicy
  **/
  @jakarta.annotation.Nullable
  public String getPodManagementPolicy() {
    return podManagementPolicy;
  }


  public void setPodManagementPolicy(String podManagementPolicy) {
    this.podManagementPolicy = podManagementPolicy;
  }


  public V1alpha1InstanceSetSpec podUpdatePolicy(String podUpdatePolicy) {
    
    this.podUpdatePolicy = podUpdatePolicy;
    return this;
  }

   /**
   * PodUpdatePolicy indicates how pods should be updated   - &#x60;StrictInPlace&#x60; indicates that only allows in-place upgrades. Any attempt to modify other fields will be rejected. - &#x60;PreferInPlace&#x60; indicates that we will first attempt an in-place upgrade of the Pod. If that fails, it will fall back to the ReCreate, where pod will be recreated. Default value is \&quot;PreferInPlace\&quot;
   * @return podUpdatePolicy
  **/
  @jakarta.annotation.Nullable
  public String getPodUpdatePolicy() {
    return podUpdatePolicy;
  }


  public void setPodUpdatePolicy(String podUpdatePolicy) {
    this.podUpdatePolicy = podUpdatePolicy;
  }


  public V1alpha1InstanceSetSpec replicas(Integer replicas) {
    
    this.replicas = replicas;
    return this;
  }

   /**
   * Specifies the desired number of replicas of the given Template. These replicas are instantiations of the same Template, with each having a consistent identity. Defaults to 1 if unspecified.
   * minimum: 0
   * @return replicas
  **/
  @jakarta.annotation.Nullable
  public Integer getReplicas() {
    return replicas;
  }


  public void setReplicas(Integer replicas) {
    this.replicas = replicas;
  }


  public V1alpha1InstanceSetSpec roleProbe(V1alpha1InstanceSetSpecRoleProbe roleProbe) {
    
    this.roleProbe = roleProbe;
    return this;
  }

   /**
   * Get roleProbe
   * @return roleProbe
  **/
  @jakarta.annotation.Nullable
  public V1alpha1InstanceSetSpecRoleProbe getRoleProbe() {
    return roleProbe;
  }


  public void setRoleProbe(V1alpha1InstanceSetSpecRoleProbe roleProbe) {
    this.roleProbe = roleProbe;
  }


  public V1alpha1InstanceSetSpec roles(List<V1alpha1InstanceSetSpecRolesInner> roles) {
    
    this.roles = roles;
    return this;
  }

  public V1alpha1InstanceSetSpec addRolesItem(V1alpha1InstanceSetSpecRolesInner rolesItem) {
    if (this.roles == null) {
      this.roles = new ArrayList<>();
    }
    this.roles.add(rolesItem);
    return this;
  }

   /**
   * A list of roles defined in the system.
   * @return roles
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1InstanceSetSpecRolesInner> getRoles() {
    return roles;
  }


  public void setRoles(List<V1alpha1InstanceSetSpecRolesInner> roles) {
    this.roles = roles;
  }


  public V1alpha1InstanceSetSpec selector(V1alpha1InstanceSetSpecSelector selector) {
    
    this.selector = selector;
    return this;
  }

   /**
   * Get selector
   * @return selector
  **/
  @jakarta.annotation.Nonnull
  public V1alpha1InstanceSetSpecSelector getSelector() {
    return selector;
  }


  public void setSelector(V1alpha1InstanceSetSpecSelector selector) {
    this.selector = selector;
  }


  public V1alpha1InstanceSetSpec service(Object service) {
    
    this.service = service;
    return this;
  }

   /**
   * Defines the behavior of a service spec. Provides read-write service. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status   Note: This field will be removed in future version.
   * @return service
  **/
  @jakarta.annotation.Nullable
  public Object getService() {
    return service;
  }


  public void setService(Object service) {
    this.service = service;
  }


  public V1alpha1InstanceSetSpec template(V1alpha1InstanceSetSpecTemplate template) {
    
    this.template = template;
    return this;
  }

   /**
   * Get template
   * @return template
  **/
  @jakarta.annotation.Nonnull
  public V1alpha1InstanceSetSpecTemplate getTemplate() {
    return template;
  }


  public void setTemplate(V1alpha1InstanceSetSpecTemplate template) {
    this.template = template;
  }


  public V1alpha1InstanceSetSpec updateStrategy(V1alpha1InstanceSetSpecUpdateStrategy updateStrategy) {
    
    this.updateStrategy = updateStrategy;
    return this;
  }

   /**
   * Get updateStrategy
   * @return updateStrategy
  **/
  @jakarta.annotation.Nullable
  public V1alpha1InstanceSetSpecUpdateStrategy getUpdateStrategy() {
    return updateStrategy;
  }


  public void setUpdateStrategy(V1alpha1InstanceSetSpecUpdateStrategy updateStrategy) {
    this.updateStrategy = updateStrategy;
  }


  public V1alpha1InstanceSetSpec volumeClaimTemplates(List<V1alpha1InstanceSetSpecInstancesInnerVolumeClaimTemplatesInner> volumeClaimTemplates) {
    
    this.volumeClaimTemplates = volumeClaimTemplates;
    return this;
  }

  public V1alpha1InstanceSetSpec addVolumeClaimTemplatesItem(V1alpha1InstanceSetSpecInstancesInnerVolumeClaimTemplatesInner volumeClaimTemplatesItem) {
    if (this.volumeClaimTemplates == null) {
      this.volumeClaimTemplates = new ArrayList<>();
    }
    this.volumeClaimTemplates.add(volumeClaimTemplatesItem);
    return this;
  }

   /**
   * Specifies a list of PersistentVolumeClaim templates that define the storage requirements for each replica. Each template specifies the desired characteristics of a persistent volume, such as storage class, size, and access modes. These templates are used to dynamically provision persistent volumes for replicas upon their creation. The final name of each PVC is generated by appending the pod&#39;s identifier to the name specified in volumeClaimTemplates[*].name.
   * @return volumeClaimTemplates
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1InstanceSetSpecInstancesInnerVolumeClaimTemplatesInner> getVolumeClaimTemplates() {
    return volumeClaimTemplates;
  }


  public void setVolumeClaimTemplates(List<V1alpha1InstanceSetSpecInstancesInnerVolumeClaimTemplatesInner> volumeClaimTemplates) {
    this.volumeClaimTemplates = volumeClaimTemplates;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1alpha1InstanceSetSpec v1alpha1InstanceSetSpec = (V1alpha1InstanceSetSpec) o;
    return Objects.equals(this.credential, v1alpha1InstanceSetSpec.credential) &&
        Objects.equals(this.defaultTemplateOrdinals, v1alpha1InstanceSetSpec.defaultTemplateOrdinals) &&
        Objects.equals(this.instances, v1alpha1InstanceSetSpec.instances) &&
        Objects.equals(this.memberUpdateStrategy, v1alpha1InstanceSetSpec.memberUpdateStrategy) &&
        Objects.equals(this.membershipReconfiguration, v1alpha1InstanceSetSpec.membershipReconfiguration) &&
        Objects.equals(this.minReadySeconds, v1alpha1InstanceSetSpec.minReadySeconds) &&
        Objects.equals(this.offlineInstances, v1alpha1InstanceSetSpec.offlineInstances) &&
        Objects.equals(this.parallelPodManagementConcurrency, v1alpha1InstanceSetSpec.parallelPodManagementConcurrency) &&
        Objects.equals(this.paused, v1alpha1InstanceSetSpec.paused) &&
        Objects.equals(this.podManagementPolicy, v1alpha1InstanceSetSpec.podManagementPolicy) &&
        Objects.equals(this.podUpdatePolicy, v1alpha1InstanceSetSpec.podUpdatePolicy) &&
        Objects.equals(this.replicas, v1alpha1InstanceSetSpec.replicas) &&
        Objects.equals(this.roleProbe, v1alpha1InstanceSetSpec.roleProbe) &&
        Objects.equals(this.roles, v1alpha1InstanceSetSpec.roles) &&
        Objects.equals(this.selector, v1alpha1InstanceSetSpec.selector) &&
        Objects.equals(this.service, v1alpha1InstanceSetSpec.service) &&
        Objects.equals(this.template, v1alpha1InstanceSetSpec.template) &&
        Objects.equals(this.updateStrategy, v1alpha1InstanceSetSpec.updateStrategy) &&
        Objects.equals(this.volumeClaimTemplates, v1alpha1InstanceSetSpec.volumeClaimTemplates);
  }

  @Override
  public int hashCode() {
    return Objects.hash(credential, defaultTemplateOrdinals, instances, memberUpdateStrategy, membershipReconfiguration, minReadySeconds, offlineInstances, parallelPodManagementConcurrency, paused, podManagementPolicy, podUpdatePolicy, replicas, roleProbe, roles, selector, service, template, updateStrategy, volumeClaimTemplates);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1alpha1InstanceSetSpec {\n");
    sb.append("    credential: ").append(toIndentedString(credential)).append("\n");
    sb.append("    defaultTemplateOrdinals: ").append(toIndentedString(defaultTemplateOrdinals)).append("\n");
    sb.append("    instances: ").append(toIndentedString(instances)).append("\n");
    sb.append("    memberUpdateStrategy: ").append(toIndentedString(memberUpdateStrategy)).append("\n");
    sb.append("    membershipReconfiguration: ").append(toIndentedString(membershipReconfiguration)).append("\n");
    sb.append("    minReadySeconds: ").append(toIndentedString(minReadySeconds)).append("\n");
    sb.append("    offlineInstances: ").append(toIndentedString(offlineInstances)).append("\n");
    sb.append("    parallelPodManagementConcurrency: ").append(toIndentedString(parallelPodManagementConcurrency)).append("\n");
    sb.append("    paused: ").append(toIndentedString(paused)).append("\n");
    sb.append("    podManagementPolicy: ").append(toIndentedString(podManagementPolicy)).append("\n");
    sb.append("    podUpdatePolicy: ").append(toIndentedString(podUpdatePolicy)).append("\n");
    sb.append("    replicas: ").append(toIndentedString(replicas)).append("\n");
    sb.append("    roleProbe: ").append(toIndentedString(roleProbe)).append("\n");
    sb.append("    roles: ").append(toIndentedString(roles)).append("\n");
    sb.append("    selector: ").append(toIndentedString(selector)).append("\n");
    sb.append("    service: ").append(toIndentedString(service)).append("\n");
    sb.append("    template: ").append(toIndentedString(template)).append("\n");
    sb.append("    updateStrategy: ").append(toIndentedString(updateStrategy)).append("\n");
    sb.append("    volumeClaimTemplates: ").append(toIndentedString(volumeClaimTemplates)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("credential");
    openapiFields.add("defaultTemplateOrdinals");
    openapiFields.add("instances");
    openapiFields.add("memberUpdateStrategy");
    openapiFields.add("membershipReconfiguration");
    openapiFields.add("minReadySeconds");
    openapiFields.add("offlineInstances");
    openapiFields.add("parallelPodManagementConcurrency");
    openapiFields.add("paused");
    openapiFields.add("podManagementPolicy");
    openapiFields.add("podUpdatePolicy");
    openapiFields.add("replicas");
    openapiFields.add("roleProbe");
    openapiFields.add("roles");
    openapiFields.add("selector");
    openapiFields.add("service");
    openapiFields.add("template");
    openapiFields.add("updateStrategy");
    openapiFields.add("volumeClaimTemplates");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("selector");
    openapiRequiredFields.add("template");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to V1alpha1InstanceSetSpec
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!V1alpha1InstanceSetSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1alpha1InstanceSetSpec is not found in the empty JSON string", V1alpha1InstanceSetSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!V1alpha1InstanceSetSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1alpha1InstanceSetSpec` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : V1alpha1InstanceSetSpec.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      // validate the optional field `credential`
      if (jsonObj.get("credential") != null && !jsonObj.get("credential").isJsonNull()) {
        V1alpha1InstanceSetSpecCredential.validateJsonObject(jsonObj.getAsJsonObject("credential"));
      }
      // validate the optional field `defaultTemplateOrdinals`
      if (jsonObj.get("defaultTemplateOrdinals") != null && !jsonObj.get("defaultTemplateOrdinals").isJsonNull()) {
        V1alpha1InstanceSetSpecDefaultTemplateOrdinals.validateJsonObject(jsonObj.getAsJsonObject("defaultTemplateOrdinals"));
      }
      if (jsonObj.get("instances") != null && !jsonObj.get("instances").isJsonNull()) {
        JsonArray jsonArrayinstances = jsonObj.getAsJsonArray("instances");
        if (jsonArrayinstances != null) {
          // ensure the json data is an array
          if (!jsonObj.get("instances").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `instances` to be an array in the JSON string but got `%s`", jsonObj.get("instances").toString()));
          }

          // validate the optional field `instances` (array)
          for (int i = 0; i < jsonArrayinstances.size(); i++) {
            V1alpha1InstanceSetSpecInstancesInner.validateJsonObject(jsonArrayinstances.get(i).getAsJsonObject());
          };
        }
      }
      if ((jsonObj.get("memberUpdateStrategy") != null && !jsonObj.get("memberUpdateStrategy").isJsonNull()) && !jsonObj.get("memberUpdateStrategy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `memberUpdateStrategy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("memberUpdateStrategy").toString()));
      }
      // validate the optional field `membershipReconfiguration`
      if (jsonObj.get("membershipReconfiguration") != null && !jsonObj.get("membershipReconfiguration").isJsonNull()) {
        V1alpha1InstanceSetSpecMembershipReconfiguration.validateJsonObject(jsonObj.getAsJsonObject("membershipReconfiguration"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("offlineInstances") != null && !jsonObj.get("offlineInstances").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `offlineInstances` to be an array in the JSON string but got `%s`", jsonObj.get("offlineInstances").toString()));
      }
      if ((jsonObj.get("podManagementPolicy") != null && !jsonObj.get("podManagementPolicy").isJsonNull()) && !jsonObj.get("podManagementPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `podManagementPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("podManagementPolicy").toString()));
      }
      if ((jsonObj.get("podUpdatePolicy") != null && !jsonObj.get("podUpdatePolicy").isJsonNull()) && !jsonObj.get("podUpdatePolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `podUpdatePolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("podUpdatePolicy").toString()));
      }
      // validate the optional field `roleProbe`
      if (jsonObj.get("roleProbe") != null && !jsonObj.get("roleProbe").isJsonNull()) {
        V1alpha1InstanceSetSpecRoleProbe.validateJsonObject(jsonObj.getAsJsonObject("roleProbe"));
      }
      if (jsonObj.get("roles") != null && !jsonObj.get("roles").isJsonNull()) {
        JsonArray jsonArrayroles = jsonObj.getAsJsonArray("roles");
        if (jsonArrayroles != null) {
          // ensure the json data is an array
          if (!jsonObj.get("roles").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `roles` to be an array in the JSON string but got `%s`", jsonObj.get("roles").toString()));
          }

          // validate the optional field `roles` (array)
          for (int i = 0; i < jsonArrayroles.size(); i++) {
            V1alpha1InstanceSetSpecRolesInner.validateJsonObject(jsonArrayroles.get(i).getAsJsonObject());
          };
        }
      }
      // validate the required field `selector`
      V1alpha1InstanceSetSpecSelector.validateJsonObject(jsonObj.getAsJsonObject("selector"));
      // validate the required field `template`
      V1alpha1InstanceSetSpecTemplate.validateJsonObject(jsonObj.getAsJsonObject("template"));
      // validate the optional field `updateStrategy`
      if (jsonObj.get("updateStrategy") != null && !jsonObj.get("updateStrategy").isJsonNull()) {
        V1alpha1InstanceSetSpecUpdateStrategy.validateJsonObject(jsonObj.getAsJsonObject("updateStrategy"));
      }
      if (jsonObj.get("volumeClaimTemplates") != null && !jsonObj.get("volumeClaimTemplates").isJsonNull()) {
        JsonArray jsonArrayvolumeClaimTemplates = jsonObj.getAsJsonArray("volumeClaimTemplates");
        if (jsonArrayvolumeClaimTemplates != null) {
          // ensure the json data is an array
          if (!jsonObj.get("volumeClaimTemplates").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `volumeClaimTemplates` to be an array in the JSON string but got `%s`", jsonObj.get("volumeClaimTemplates").toString()));
          }

          // validate the optional field `volumeClaimTemplates` (array)
          for (int i = 0; i < jsonArrayvolumeClaimTemplates.size(); i++) {
            V1alpha1InstanceSetSpecInstancesInnerVolumeClaimTemplatesInner.validateJsonObject(jsonArrayvolumeClaimTemplates.get(i).getAsJsonObject());
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1alpha1InstanceSetSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1alpha1InstanceSetSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1alpha1InstanceSetSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1alpha1InstanceSetSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<V1alpha1InstanceSetSpec>() {
           @Override
           public void write(JsonWriter out, V1alpha1InstanceSetSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1alpha1InstanceSetSpec read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of V1alpha1InstanceSetSpec given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of V1alpha1InstanceSetSpec
  * @throws IOException if the JSON string is invalid with respect to V1alpha1InstanceSetSpec
  */
  public static V1alpha1InstanceSetSpec fromJson(String jsonString) throws IOException {
    return new JSON().getGson().fromJson(jsonString, V1alpha1InstanceSetSpec.class);
  }

 /**
  * Convert an instance of V1alpha1InstanceSetSpec to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return new JSON().getGson().toJson(this);
  }
}

