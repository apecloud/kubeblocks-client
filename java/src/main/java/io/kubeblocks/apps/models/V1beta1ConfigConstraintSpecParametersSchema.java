/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.25.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.kubeblocks.apps.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import io.kubernetes.client.openapi.JSON;

/**
 * Defines a list of parameters including their names, default values, descriptions, types, and constraints (permissible values or the range of valid values).
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-08-05T13:58:00.823553Z[Etc/UTC]")
public class V1beta1ConfigConstraintSpecParametersSchema {
  public static final String SERIALIZED_NAME_CUE = "cue";
  @SerializedName(SERIALIZED_NAME_CUE)
  private String cue;

  public static final String SERIALIZED_NAME_SCHEMA_IN_J_S_O_N = "schemaInJSON";
  @SerializedName(SERIALIZED_NAME_SCHEMA_IN_J_S_O_N)
  private Object schemaInJSON;

  public static final String SERIALIZED_NAME_TOP_LEVEL_KEY = "topLevelKey";
  @SerializedName(SERIALIZED_NAME_TOP_LEVEL_KEY)
  private String topLevelKey;

  public V1beta1ConfigConstraintSpecParametersSchema() {
  }

  public V1beta1ConfigConstraintSpecParametersSchema cue(String cue) {
    
    this.cue = cue;
    return this;
  }

   /**
   * Hold a string that contains a script written in CUE language that defines a list of configuration items. Each item is detailed with its name, default value, description, type (e.g. string, integer, float), and constraints (permissible values or the valid range of values).   CUE (Configure, Unify, Execute) is a declarative language designed for defining and validating complex data configurations. It is particularly useful in environments like K8s where complex configurations and validation rules are common.   This script functions as a validator for user-provided configurations, ensuring compliance with the established specifications and constraints.
   * @return cue
  **/
  @jakarta.annotation.Nullable
  public String getCue() {
    return cue;
  }


  public void setCue(String cue) {
    this.cue = cue;
  }


  public V1beta1ConfigConstraintSpecParametersSchema schemaInJSON(Object schemaInJSON) {
    
    this.schemaInJSON = schemaInJSON;
    return this;
  }

   /**
   * Generated from the &#39;cue&#39; field and transformed into a JSON format.
   * @return schemaInJSON
  **/
  @jakarta.annotation.Nullable
  public Object getSchemaInJSON() {
    return schemaInJSON;
  }


  public void setSchemaInJSON(Object schemaInJSON) {
    this.schemaInJSON = schemaInJSON;
  }


  public V1beta1ConfigConstraintSpecParametersSchema topLevelKey(String topLevelKey) {
    
    this.topLevelKey = topLevelKey;
    return this;
  }

   /**
   * Specifies the top-level key in the &#39;configSchema.cue&#39; that organizes the validation rules for parameters. This key must exist within the CUE script defined in &#39;configSchema.cue&#39;.
   * @return topLevelKey
  **/
  @jakarta.annotation.Nullable
  public String getTopLevelKey() {
    return topLevelKey;
  }


  public void setTopLevelKey(String topLevelKey) {
    this.topLevelKey = topLevelKey;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1beta1ConfigConstraintSpecParametersSchema v1beta1ConfigConstraintSpecParametersSchema = (V1beta1ConfigConstraintSpecParametersSchema) o;
    return Objects.equals(this.cue, v1beta1ConfigConstraintSpecParametersSchema.cue) &&
        Objects.equals(this.schemaInJSON, v1beta1ConfigConstraintSpecParametersSchema.schemaInJSON) &&
        Objects.equals(this.topLevelKey, v1beta1ConfigConstraintSpecParametersSchema.topLevelKey);
  }

  @Override
  public int hashCode() {
    return Objects.hash(cue, schemaInJSON, topLevelKey);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1beta1ConfigConstraintSpecParametersSchema {\n");
    sb.append("    cue: ").append(toIndentedString(cue)).append("\n");
    sb.append("    schemaInJSON: ").append(toIndentedString(schemaInJSON)).append("\n");
    sb.append("    topLevelKey: ").append(toIndentedString(topLevelKey)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("cue");
    openapiFields.add("schemaInJSON");
    openapiFields.add("topLevelKey");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to V1beta1ConfigConstraintSpecParametersSchema
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!V1beta1ConfigConstraintSpecParametersSchema.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1beta1ConfigConstraintSpecParametersSchema is not found in the empty JSON string", V1beta1ConfigConstraintSpecParametersSchema.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!V1beta1ConfigConstraintSpecParametersSchema.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1beta1ConfigConstraintSpecParametersSchema` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if ((jsonObj.get("cue") != null && !jsonObj.get("cue").isJsonNull()) && !jsonObj.get("cue").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cue` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cue").toString()));
      }
      if ((jsonObj.get("topLevelKey") != null && !jsonObj.get("topLevelKey").isJsonNull()) && !jsonObj.get("topLevelKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `topLevelKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("topLevelKey").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1beta1ConfigConstraintSpecParametersSchema.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1beta1ConfigConstraintSpecParametersSchema' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1beta1ConfigConstraintSpecParametersSchema> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1beta1ConfigConstraintSpecParametersSchema.class));

       return (TypeAdapter<T>) new TypeAdapter<V1beta1ConfigConstraintSpecParametersSchema>() {
           @Override
           public void write(JsonWriter out, V1beta1ConfigConstraintSpecParametersSchema value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1beta1ConfigConstraintSpecParametersSchema read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of V1beta1ConfigConstraintSpecParametersSchema given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of V1beta1ConfigConstraintSpecParametersSchema
  * @throws IOException if the JSON string is invalid with respect to V1beta1ConfigConstraintSpecParametersSchema
  */
  public static V1beta1ConfigConstraintSpecParametersSchema fromJson(String jsonString) throws IOException {
    return new JSON().getGson().fromJson(jsonString, V1beta1ConfigConstraintSpecParametersSchema.class);
  }

 /**
  * Convert an instance of V1beta1ConfigConstraintSpecParametersSchema to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return new JSON().getGson().toJson(this);
  }
}

