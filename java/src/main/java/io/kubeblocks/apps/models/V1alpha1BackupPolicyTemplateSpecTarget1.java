/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.21.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.kubeblocks.apps.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.kubeblocks.apps.models.V1alpha1BackupPolicyTemplateSpecTargetConnectionCredentialKey;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * target instance for backup.
 */
@ApiModel(description = "target instance for backup.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-01-31T07:53:54.854Z[Etc/UTC]")
public class V1alpha1BackupPolicyTemplateSpecTarget1 {
  public static final String SERIALIZED_NAME_ACCOUNT = "account";
  @SerializedName(SERIALIZED_NAME_ACCOUNT)
  private String account;

  public static final String SERIALIZED_NAME_CONNECTION_CREDENTIAL_KEY = "connectionCredentialKey";
  @SerializedName(SERIALIZED_NAME_CONNECTION_CREDENTIAL_KEY)
  private V1alpha1BackupPolicyTemplateSpecTargetConnectionCredentialKey connectionCredentialKey;

  public static final String SERIALIZED_NAME_ROLE = "role";
  @SerializedName(SERIALIZED_NAME_ROLE)
  private String role;

  /**
   * PodSelectionStrategy specifies the strategy to select when multiple pods are selected for backup target. Valid values are: - Any: select any one pod that match the labelsSelector. - All: select all pods that match the labelsSelector.
   */
  @JsonAdapter(StrategyEnum.Adapter.class)
  public enum StrategyEnum {
    ANY("Any"),
    
    ALL("All");

    private String value;

    StrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StrategyEnum fromValue(String value) {
      for (StrategyEnum b : StrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StrategyEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_STRATEGY = "strategy";
  @SerializedName(SERIALIZED_NAME_STRATEGY)
  private StrategyEnum strategy;


  public V1alpha1BackupPolicyTemplateSpecTarget1 account(String account) {
    
    this.account = account;
    return this;
  }

   /**
   * refer to spec.componentDef.systemAccounts.accounts[*].name in ClusterDefinition. the secret created by this account will be used to connect the database. if not set, the secret created by spec.ConnectionCredential of the ClusterDefinition will be used. it will be transformed to a secret for BackupPolicy&#39;s target secret.
   * @return account
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "refer to spec.componentDef.systemAccounts.accounts[*].name in ClusterDefinition. the secret created by this account will be used to connect the database. if not set, the secret created by spec.ConnectionCredential of the ClusterDefinition will be used. it will be transformed to a secret for BackupPolicy's target secret.")

  public String getAccount() {
    return account;
  }


  public void setAccount(String account) {
    this.account = account;
  }


  public V1alpha1BackupPolicyTemplateSpecTarget1 connectionCredentialKey(V1alpha1BackupPolicyTemplateSpecTargetConnectionCredentialKey connectionCredentialKey) {
    
    this.connectionCredentialKey = connectionCredentialKey;
    return this;
  }

   /**
   * Get connectionCredentialKey
   * @return connectionCredentialKey
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public V1alpha1BackupPolicyTemplateSpecTargetConnectionCredentialKey getConnectionCredentialKey() {
    return connectionCredentialKey;
  }


  public void setConnectionCredentialKey(V1alpha1BackupPolicyTemplateSpecTargetConnectionCredentialKey connectionCredentialKey) {
    this.connectionCredentialKey = connectionCredentialKey;
  }


  public V1alpha1BackupPolicyTemplateSpecTarget1 role(String role) {
    
    this.role = role;
    return this;
  }

   /**
   * select instance of corresponding role for backup, role are: - the name of Leader/Follower/Leaner for Consensus component. - primary or secondary for Replication component. finally, invalid role of the component will be ignored. such as if workload type is Replication and component&#39;s replicas is 1, the secondary role is invalid. and it also will be ignored when component is Stateful/Stateless. the role will be transformed to a role LabelSelector for BackupPolicy&#39;s target attribute.
   * @return role
  **/
  @ApiModelProperty(required = true, value = "select instance of corresponding role for backup, role are: - the name of Leader/Follower/Leaner for Consensus component. - primary or secondary for Replication component. finally, invalid role of the component will be ignored. such as if workload type is Replication and component's replicas is 1, the secondary role is invalid. and it also will be ignored when component is Stateful/Stateless. the role will be transformed to a role LabelSelector for BackupPolicy's target attribute.")

  public String getRole() {
    return role;
  }


  public void setRole(String role) {
    this.role = role;
  }


  public V1alpha1BackupPolicyTemplateSpecTarget1 strategy(StrategyEnum strategy) {
    
    this.strategy = strategy;
    return this;
  }

   /**
   * PodSelectionStrategy specifies the strategy to select when multiple pods are selected for backup target. Valid values are: - Any: select any one pod that match the labelsSelector. - All: select all pods that match the labelsSelector.
   * @return strategy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "PodSelectionStrategy specifies the strategy to select when multiple pods are selected for backup target. Valid values are: - Any: select any one pod that match the labelsSelector. - All: select all pods that match the labelsSelector.")

  public StrategyEnum getStrategy() {
    return strategy;
  }


  public void setStrategy(StrategyEnum strategy) {
    this.strategy = strategy;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1alpha1BackupPolicyTemplateSpecTarget1 v1alpha1BackupPolicyTemplateSpecTarget1 = (V1alpha1BackupPolicyTemplateSpecTarget1) o;
    return Objects.equals(this.account, v1alpha1BackupPolicyTemplateSpecTarget1.account) &&
        Objects.equals(this.connectionCredentialKey, v1alpha1BackupPolicyTemplateSpecTarget1.connectionCredentialKey) &&
        Objects.equals(this.role, v1alpha1BackupPolicyTemplateSpecTarget1.role) &&
        Objects.equals(this.strategy, v1alpha1BackupPolicyTemplateSpecTarget1.strategy);
  }

  @Override
  public int hashCode() {
    return Objects.hash(account, connectionCredentialKey, role, strategy);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1alpha1BackupPolicyTemplateSpecTarget1 {\n");
    sb.append("    account: ").append(toIndentedString(account)).append("\n");
    sb.append("    connectionCredentialKey: ").append(toIndentedString(connectionCredentialKey)).append("\n");
    sb.append("    role: ").append(toIndentedString(role)).append("\n");
    sb.append("    strategy: ").append(toIndentedString(strategy)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

