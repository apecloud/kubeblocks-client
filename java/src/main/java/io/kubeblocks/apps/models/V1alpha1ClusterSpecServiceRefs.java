/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.21.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.kubeblocks.apps.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * V1alpha1ClusterSpecServiceRefs
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-01-31T07:24:37.743Z[Etc/UTC]")
public class V1alpha1ClusterSpecServiceRefs {
  public static final String SERIALIZED_NAME_CLUSTER = "cluster";
  @SerializedName(SERIALIZED_NAME_CLUSTER)
  private String cluster;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NAMESPACE = "namespace";
  @SerializedName(SERIALIZED_NAME_NAMESPACE)
  private String namespace;

  public static final String SERIALIZED_NAME_SERVICE_DESCRIPTOR = "serviceDescriptor";
  @SerializedName(SERIALIZED_NAME_SERVICE_DESCRIPTOR)
  private String serviceDescriptor;


  public V1alpha1ClusterSpecServiceRefs cluster(String cluster) {
    
    this.cluster = cluster;
    return this;
  }

   /**
   * When referencing a service provided by other KubeBlocks cluster, you need to provide the name of the Cluster being referenced. By default, when other KubeBlocks Cluster are referenced, the ClusterDefinition.spec.connectionCredential secret corresponding to the referenced Cluster will be used to bind to the current component. Currently, if a KubeBlocks cluster is to be referenced, the connection credential secret should include and correspond to the following fields: endpoint, port, username, and password. Under this referencing approach, the ServiceKind and ServiceVersion of service reference declaration defined in the ClusterDefinition will not be validated. If both Cluster and ServiceDescriptor are specified, the Cluster takes precedence.
   * @return cluster
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "When referencing a service provided by other KubeBlocks cluster, you need to provide the name of the Cluster being referenced. By default, when other KubeBlocks Cluster are referenced, the ClusterDefinition.spec.connectionCredential secret corresponding to the referenced Cluster will be used to bind to the current component. Currently, if a KubeBlocks cluster is to be referenced, the connection credential secret should include and correspond to the following fields: endpoint, port, username, and password. Under this referencing approach, the ServiceKind and ServiceVersion of service reference declaration defined in the ClusterDefinition will not be validated. If both Cluster and ServiceDescriptor are specified, the Cluster takes precedence.")

  public String getCluster() {
    return cluster;
  }


  public void setCluster(String cluster) {
    this.cluster = cluster;
  }


  public V1alpha1ClusterSpecServiceRefs name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * name of the service reference declaration. references the serviceRefDeclaration name defined in clusterDefinition.componentDefs[*].serviceRefDeclarations[*].name
   * @return name
  **/
  @ApiModelProperty(required = true, value = "name of the service reference declaration. references the serviceRefDeclaration name defined in clusterDefinition.componentDefs[*].serviceRefDeclarations[*].name")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public V1alpha1ClusterSpecServiceRefs namespace(String namespace) {
    
    this.namespace = namespace;
    return this;
  }

   /**
   * namespace defines the namespace of the referenced Cluster or the namespace of the referenced ServiceDescriptor object. If not set, the referenced Cluster and ServiceDescriptor will be searched in the namespace of the current cluster by default.
   * @return namespace
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "namespace defines the namespace of the referenced Cluster or the namespace of the referenced ServiceDescriptor object. If not set, the referenced Cluster and ServiceDescriptor will be searched in the namespace of the current cluster by default.")

  public String getNamespace() {
    return namespace;
  }


  public void setNamespace(String namespace) {
    this.namespace = namespace;
  }


  public V1alpha1ClusterSpecServiceRefs serviceDescriptor(String serviceDescriptor) {
    
    this.serviceDescriptor = serviceDescriptor;
    return this;
  }

   /**
   * serviceDescriptor defines the service descriptor of the service provided by external sources. When referencing a service provided by external sources, you need to provide the ServiceDescriptor object name to establish the service binding. And serviceDescriptor is the name of the ServiceDescriptor object, furthermore, the ServiceDescriptor.spec.serviceKind and ServiceDescriptor.spec.serviceVersion should match clusterDefinition.componentDefs[*].serviceRefDeclarations[*].serviceRefDeclarationSpecs[*].serviceKind and the regular expression defines in clusterDefinition.componentDefs[*].serviceRefDeclarations[*].serviceRefDeclarationSpecs[*].serviceVersion. If both Cluster and ServiceDescriptor are specified, the Cluster takes precedence.
   * @return serviceDescriptor
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "serviceDescriptor defines the service descriptor of the service provided by external sources. When referencing a service provided by external sources, you need to provide the ServiceDescriptor object name to establish the service binding. And serviceDescriptor is the name of the ServiceDescriptor object, furthermore, the ServiceDescriptor.spec.serviceKind and ServiceDescriptor.spec.serviceVersion should match clusterDefinition.componentDefs[*].serviceRefDeclarations[*].serviceRefDeclarationSpecs[*].serviceKind and the regular expression defines in clusterDefinition.componentDefs[*].serviceRefDeclarations[*].serviceRefDeclarationSpecs[*].serviceVersion. If both Cluster and ServiceDescriptor are specified, the Cluster takes precedence.")

  public String getServiceDescriptor() {
    return serviceDescriptor;
  }


  public void setServiceDescriptor(String serviceDescriptor) {
    this.serviceDescriptor = serviceDescriptor;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1alpha1ClusterSpecServiceRefs v1alpha1ClusterSpecServiceRefs = (V1alpha1ClusterSpecServiceRefs) o;
    return Objects.equals(this.cluster, v1alpha1ClusterSpecServiceRefs.cluster) &&
        Objects.equals(this.name, v1alpha1ClusterSpecServiceRefs.name) &&
        Objects.equals(this.namespace, v1alpha1ClusterSpecServiceRefs.namespace) &&
        Objects.equals(this.serviceDescriptor, v1alpha1ClusterSpecServiceRefs.serviceDescriptor);
  }

  @Override
  public int hashCode() {
    return Objects.hash(cluster, name, namespace, serviceDescriptor);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1alpha1ClusterSpecServiceRefs {\n");
    sb.append("    cluster: ").append(toIndentedString(cluster)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    namespace: ").append(toIndentedString(namespace)).append("\n");
    sb.append("    serviceDescriptor: ").append(toIndentedString(serviceDescriptor)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

