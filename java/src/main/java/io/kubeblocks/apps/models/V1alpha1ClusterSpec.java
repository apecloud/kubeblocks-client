/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.21.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.kubeblocks.apps.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecAffinity;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecBackup;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecComponentSpecs;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecMonitor;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecNetwork;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecResources;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecStorage;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * ClusterSpec defines the desired state of Cluster.
 */
@ApiModel(description = "ClusterSpec defines the desired state of Cluster.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-01-31T07:24:37.743Z[Etc/UTC]")
public class V1alpha1ClusterSpec {
  public static final String SERIALIZED_NAME_AFFINITY = "affinity";
  @SerializedName(SERIALIZED_NAME_AFFINITY)
  private V1alpha1ClusterSpecAffinity affinity;

  /**
   * availabilityPolicy describes the availability policy, including zone, node, and none.
   */
  @JsonAdapter(AvailabilityPolicyEnum.Adapter.class)
  public enum AvailabilityPolicyEnum {
    ZONE("zone"),
    
    NODE("node"),
    
    NONE("none");

    private String value;

    AvailabilityPolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AvailabilityPolicyEnum fromValue(String value) {
      for (AvailabilityPolicyEnum b : AvailabilityPolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AvailabilityPolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AvailabilityPolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AvailabilityPolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AvailabilityPolicyEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_AVAILABILITY_POLICY = "availabilityPolicy";
  @SerializedName(SERIALIZED_NAME_AVAILABILITY_POLICY)
  private AvailabilityPolicyEnum availabilityPolicy;

  public static final String SERIALIZED_NAME_BACKUP = "backup";
  @SerializedName(SERIALIZED_NAME_BACKUP)
  private V1alpha1ClusterSpecBackup backup;

  public static final String SERIALIZED_NAME_CLUSTER_DEFINITION_REF = "clusterDefinitionRef";
  @SerializedName(SERIALIZED_NAME_CLUSTER_DEFINITION_REF)
  private String clusterDefinitionRef;

  public static final String SERIALIZED_NAME_CLUSTER_VERSION_REF = "clusterVersionRef";
  @SerializedName(SERIALIZED_NAME_CLUSTER_VERSION_REF)
  private String clusterVersionRef;

  public static final String SERIALIZED_NAME_COMPONENT_SPECS = "componentSpecs";
  @SerializedName(SERIALIZED_NAME_COMPONENT_SPECS)
  private List<V1alpha1ClusterSpecComponentSpecs> componentSpecs = null;

  public static final String SERIALIZED_NAME_MONITOR = "monitor";
  @SerializedName(SERIALIZED_NAME_MONITOR)
  private V1alpha1ClusterSpecMonitor monitor;

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private V1alpha1ClusterSpecNetwork network;

  public static final String SERIALIZED_NAME_REPLICAS = "replicas";
  @SerializedName(SERIALIZED_NAME_REPLICAS)
  private Integer replicas;

  public static final String SERIALIZED_NAME_RESOURCES = "resources";
  @SerializedName(SERIALIZED_NAME_RESOURCES)
  private V1alpha1ClusterSpecResources resources;

  public static final String SERIALIZED_NAME_SERVICES = "services";
  @SerializedName(SERIALIZED_NAME_SERVICES)
  private Object services;

  public static final String SERIALIZED_NAME_STORAGE = "storage";
  @SerializedName(SERIALIZED_NAME_STORAGE)
  private V1alpha1ClusterSpecStorage storage;

  /**
   * tenancy describes how pods are distributed across node. SharedNode means multiple pods may share the same node. DedicatedNode means each pod runs on their own dedicated node.
   */
  @JsonAdapter(TenancyEnum.Adapter.class)
  public enum TenancyEnum {
    SHAREDNODE("SharedNode"),
    
    DEDICATEDNODE("DedicatedNode");

    private String value;

    TenancyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TenancyEnum fromValue(String value) {
      for (TenancyEnum b : TenancyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TenancyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TenancyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TenancyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TenancyEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_TENANCY = "tenancy";
  @SerializedName(SERIALIZED_NAME_TENANCY)
  private TenancyEnum tenancy;

  /**
   * Cluster termination policy. Valid values are DoNotTerminate, Halt, Delete, WipeOut. DoNotTerminate will block delete operation. Halt will delete workload resources such as statefulset, deployment workloads but keep PVCs. Delete is based on Halt and deletes PVCs. WipeOut is based on Delete and wipe out all volume snapshots and snapshot data from backup storage location.
   */
  @JsonAdapter(TerminationPolicyEnum.Adapter.class)
  public enum TerminationPolicyEnum {
    DONOTTERMINATE("DoNotTerminate"),
    
    HALT("Halt"),
    
    DELETE("Delete"),
    
    WIPEOUT("WipeOut");

    private String value;

    TerminationPolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TerminationPolicyEnum fromValue(String value) {
      for (TerminationPolicyEnum b : TerminationPolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TerminationPolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TerminationPolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TerminationPolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TerminationPolicyEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_TERMINATION_POLICY = "terminationPolicy";
  @SerializedName(SERIALIZED_NAME_TERMINATION_POLICY)
  private TerminationPolicyEnum terminationPolicy;

  public static final String SERIALIZED_NAME_TOLERATIONS = "tolerations";
  @SerializedName(SERIALIZED_NAME_TOLERATIONS)
  private Object tolerations;


  public V1alpha1ClusterSpec affinity(V1alpha1ClusterSpecAffinity affinity) {
    
    this.affinity = affinity;
    return this;
  }

   /**
   * Get affinity
   * @return affinity
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public V1alpha1ClusterSpecAffinity getAffinity() {
    return affinity;
  }


  public void setAffinity(V1alpha1ClusterSpecAffinity affinity) {
    this.affinity = affinity;
  }


  public V1alpha1ClusterSpec availabilityPolicy(AvailabilityPolicyEnum availabilityPolicy) {
    
    this.availabilityPolicy = availabilityPolicy;
    return this;
  }

   /**
   * availabilityPolicy describes the availability policy, including zone, node, and none.
   * @return availabilityPolicy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "availabilityPolicy describes the availability policy, including zone, node, and none.")

  public AvailabilityPolicyEnum getAvailabilityPolicy() {
    return availabilityPolicy;
  }


  public void setAvailabilityPolicy(AvailabilityPolicyEnum availabilityPolicy) {
    this.availabilityPolicy = availabilityPolicy;
  }


  public V1alpha1ClusterSpec backup(V1alpha1ClusterSpecBackup backup) {
    
    this.backup = backup;
    return this;
  }

   /**
   * Get backup
   * @return backup
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public V1alpha1ClusterSpecBackup getBackup() {
    return backup;
  }


  public void setBackup(V1alpha1ClusterSpecBackup backup) {
    this.backup = backup;
  }


  public V1alpha1ClusterSpec clusterDefinitionRef(String clusterDefinitionRef) {
    
    this.clusterDefinitionRef = clusterDefinitionRef;
    return this;
  }

   /**
   * Cluster referencing ClusterDefinition name. This is an immutable attribute. If ClusterDefRef is not specified, ComponentDef must be specified for each Component in ComponentSpecs.
   * @return clusterDefinitionRef
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Cluster referencing ClusterDefinition name. This is an immutable attribute. If ClusterDefRef is not specified, ComponentDef must be specified for each Component in ComponentSpecs.")

  public String getClusterDefinitionRef() {
    return clusterDefinitionRef;
  }


  public void setClusterDefinitionRef(String clusterDefinitionRef) {
    this.clusterDefinitionRef = clusterDefinitionRef;
  }


  public V1alpha1ClusterSpec clusterVersionRef(String clusterVersionRef) {
    
    this.clusterVersionRef = clusterVersionRef;
    return this;
  }

   /**
   * Cluster referencing ClusterVersion name.
   * @return clusterVersionRef
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Cluster referencing ClusterVersion name.")

  public String getClusterVersionRef() {
    return clusterVersionRef;
  }


  public void setClusterVersionRef(String clusterVersionRef) {
    this.clusterVersionRef = clusterVersionRef;
  }


  public V1alpha1ClusterSpec componentSpecs(List<V1alpha1ClusterSpecComponentSpecs> componentSpecs) {
    
    this.componentSpecs = componentSpecs;
    return this;
  }

  public V1alpha1ClusterSpec addComponentSpecsItem(V1alpha1ClusterSpecComponentSpecs componentSpecsItem) {
    if (this.componentSpecs == null) {
      this.componentSpecs = new ArrayList<>();
    }
    this.componentSpecs.add(componentSpecsItem);
    return this;
  }

   /**
   * List of componentSpecs you want to replace in ClusterDefinition and ClusterVersion. It will replace the field in ClusterDefinition&#39;s and ClusterVersion&#39;s component if type is matching.
   * @return componentSpecs
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "List of componentSpecs you want to replace in ClusterDefinition and ClusterVersion. It will replace the field in ClusterDefinition's and ClusterVersion's component if type is matching.")

  public List<V1alpha1ClusterSpecComponentSpecs> getComponentSpecs() {
    return componentSpecs;
  }


  public void setComponentSpecs(List<V1alpha1ClusterSpecComponentSpecs> componentSpecs) {
    this.componentSpecs = componentSpecs;
  }


  public V1alpha1ClusterSpec monitor(V1alpha1ClusterSpecMonitor monitor) {
    
    this.monitor = monitor;
    return this;
  }

   /**
   * Get monitor
   * @return monitor
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public V1alpha1ClusterSpecMonitor getMonitor() {
    return monitor;
  }


  public void setMonitor(V1alpha1ClusterSpecMonitor monitor) {
    this.monitor = monitor;
  }


  public V1alpha1ClusterSpec network(V1alpha1ClusterSpecNetwork network) {
    
    this.network = network;
    return this;
  }

   /**
   * Get network
   * @return network
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public V1alpha1ClusterSpecNetwork getNetwork() {
    return network;
  }


  public void setNetwork(V1alpha1ClusterSpecNetwork network) {
    this.network = network;
  }


  public V1alpha1ClusterSpec replicas(Integer replicas) {
    
    this.replicas = replicas;
    return this;
  }

   /**
   * replicas specifies the replicas of the first componentSpec, if the replicas of the first componentSpec is specified, this value will be ignored.
   * @return replicas
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "replicas specifies the replicas of the first componentSpec, if the replicas of the first componentSpec is specified, this value will be ignored.")

  public Integer getReplicas() {
    return replicas;
  }


  public void setReplicas(Integer replicas) {
    this.replicas = replicas;
  }


  public V1alpha1ClusterSpec resources(V1alpha1ClusterSpecResources resources) {
    
    this.resources = resources;
    return this;
  }

   /**
   * Get resources
   * @return resources
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public V1alpha1ClusterSpecResources getResources() {
    return resources;
  }


  public void setResources(V1alpha1ClusterSpecResources resources) {
    this.resources = resources;
  }


  public V1alpha1ClusterSpec services(Object services) {
    
    this.services = services;
    return this;
  }

   /**
   * services defines the services to access a cluster.
   * @return services
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "services defines the services to access a cluster.")

  public Object getServices() {
    return services;
  }


  public void setServices(Object services) {
    this.services = services;
  }


  public V1alpha1ClusterSpec storage(V1alpha1ClusterSpecStorage storage) {
    
    this.storage = storage;
    return this;
  }

   /**
   * Get storage
   * @return storage
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public V1alpha1ClusterSpecStorage getStorage() {
    return storage;
  }


  public void setStorage(V1alpha1ClusterSpecStorage storage) {
    this.storage = storage;
  }


  public V1alpha1ClusterSpec tenancy(TenancyEnum tenancy) {
    
    this.tenancy = tenancy;
    return this;
  }

   /**
   * tenancy describes how pods are distributed across node. SharedNode means multiple pods may share the same node. DedicatedNode means each pod runs on their own dedicated node.
   * @return tenancy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "tenancy describes how pods are distributed across node. SharedNode means multiple pods may share the same node. DedicatedNode means each pod runs on their own dedicated node.")

  public TenancyEnum getTenancy() {
    return tenancy;
  }


  public void setTenancy(TenancyEnum tenancy) {
    this.tenancy = tenancy;
  }


  public V1alpha1ClusterSpec terminationPolicy(TerminationPolicyEnum terminationPolicy) {
    
    this.terminationPolicy = terminationPolicy;
    return this;
  }

   /**
   * Cluster termination policy. Valid values are DoNotTerminate, Halt, Delete, WipeOut. DoNotTerminate will block delete operation. Halt will delete workload resources such as statefulset, deployment workloads but keep PVCs. Delete is based on Halt and deletes PVCs. WipeOut is based on Delete and wipe out all volume snapshots and snapshot data from backup storage location.
   * @return terminationPolicy
  **/
  @ApiModelProperty(required = true, value = "Cluster termination policy. Valid values are DoNotTerminate, Halt, Delete, WipeOut. DoNotTerminate will block delete operation. Halt will delete workload resources such as statefulset, deployment workloads but keep PVCs. Delete is based on Halt and deletes PVCs. WipeOut is based on Delete and wipe out all volume snapshots and snapshot data from backup storage location.")

  public TerminationPolicyEnum getTerminationPolicy() {
    return terminationPolicy;
  }


  public void setTerminationPolicy(TerminationPolicyEnum terminationPolicy) {
    this.terminationPolicy = terminationPolicy;
  }


  public V1alpha1ClusterSpec tolerations(Object tolerations) {
    
    this.tolerations = tolerations;
    return this;
  }

   /**
   * tolerations are attached to tolerate any taint that matches the triple &#x60;key,value,effect&#x60; using the matching operator &#x60;operator&#x60;.
   * @return tolerations
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "tolerations are attached to tolerate any taint that matches the triple `key,value,effect` using the matching operator `operator`.")

  public Object getTolerations() {
    return tolerations;
  }


  public void setTolerations(Object tolerations) {
    this.tolerations = tolerations;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1alpha1ClusterSpec v1alpha1ClusterSpec = (V1alpha1ClusterSpec) o;
    return Objects.equals(this.affinity, v1alpha1ClusterSpec.affinity) &&
        Objects.equals(this.availabilityPolicy, v1alpha1ClusterSpec.availabilityPolicy) &&
        Objects.equals(this.backup, v1alpha1ClusterSpec.backup) &&
        Objects.equals(this.clusterDefinitionRef, v1alpha1ClusterSpec.clusterDefinitionRef) &&
        Objects.equals(this.clusterVersionRef, v1alpha1ClusterSpec.clusterVersionRef) &&
        Objects.equals(this.componentSpecs, v1alpha1ClusterSpec.componentSpecs) &&
        Objects.equals(this.monitor, v1alpha1ClusterSpec.monitor) &&
        Objects.equals(this.network, v1alpha1ClusterSpec.network) &&
        Objects.equals(this.replicas, v1alpha1ClusterSpec.replicas) &&
        Objects.equals(this.resources, v1alpha1ClusterSpec.resources) &&
        Objects.equals(this.services, v1alpha1ClusterSpec.services) &&
        Objects.equals(this.storage, v1alpha1ClusterSpec.storage) &&
        Objects.equals(this.tenancy, v1alpha1ClusterSpec.tenancy) &&
        Objects.equals(this.terminationPolicy, v1alpha1ClusterSpec.terminationPolicy) &&
        Objects.equals(this.tolerations, v1alpha1ClusterSpec.tolerations);
  }

  @Override
  public int hashCode() {
    return Objects.hash(affinity, availabilityPolicy, backup, clusterDefinitionRef, clusterVersionRef, componentSpecs, monitor, network, replicas, resources, services, storage, tenancy, terminationPolicy, tolerations);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1alpha1ClusterSpec {\n");
    sb.append("    affinity: ").append(toIndentedString(affinity)).append("\n");
    sb.append("    availabilityPolicy: ").append(toIndentedString(availabilityPolicy)).append("\n");
    sb.append("    backup: ").append(toIndentedString(backup)).append("\n");
    sb.append("    clusterDefinitionRef: ").append(toIndentedString(clusterDefinitionRef)).append("\n");
    sb.append("    clusterVersionRef: ").append(toIndentedString(clusterVersionRef)).append("\n");
    sb.append("    componentSpecs: ").append(toIndentedString(componentSpecs)).append("\n");
    sb.append("    monitor: ").append(toIndentedString(monitor)).append("\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    replicas: ").append(toIndentedString(replicas)).append("\n");
    sb.append("    resources: ").append(toIndentedString(resources)).append("\n");
    sb.append("    services: ").append(toIndentedString(services)).append("\n");
    sb.append("    storage: ").append(toIndentedString(storage)).append("\n");
    sb.append("    tenancy: ").append(toIndentedString(tenancy)).append("\n");
    sb.append("    terminationPolicy: ").append(toIndentedString(terminationPolicy)).append("\n");
    sb.append("    tolerations: ").append(toIndentedString(tolerations)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

